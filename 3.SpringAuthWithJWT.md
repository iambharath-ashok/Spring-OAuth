# Spring Boot Authentication with Json Web Token

-	Create Secuirty Config class with JwtAuthenticationEntryPoint, JwtAuthenticationFilter, AuthenticationManagerBuilder and HttpSecurity configurations


##	WebSecurityConfigurerAdapter

-	Provides default implementation
-	We can provide custom implementation by extending that

##	CustomUserDetailsService

-	This is a custom class that implements UserDetailsService interface and provides implementation for loadUserByUsername(String name) method

			UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;

-	This is used to perform role based checkup from DB or ldap
-	the loadUserByUsername() method returns a UserDetails object that Spring Security uses for performing various authentication and role based validations

##	Created utility class for generating and verifying JWT

-	Utility class will be used for generating a JWT after a user logs in successfully, and validating the JWT sent in the Authorization header of the requests



##	JwtAuthenticationEntryPoint

-	This is just an entry point, this just used to return 401 unauthorized error to clients that try to access a protected resource without proper authentication
-	It implements Spring Security’s AuthenticationEntryPoint interface.

##	JwtAuthenticationFilter

-	We’ll use JWTAuthenticationFilter to implement a filter that:

	-	reads JWT authentication token from the Authorization header of all the requests
	-	validates the token
	-	loads the user details associated with that token.
	-	If its valid then sets the user details in Spring Security’s SecurityContext. 
	-	Spring Security uses the user details to perform authorization checks
	
	
##	AuthenticationManagerBuilder and AuthenticationManager

-	AuthenticationManagerBuilder is used to create an AuthenticationManager instance which is the main Spring Security interface for authenticating a user
-	We can use AuthenticationManagerBuilder to build in-memory authentication, LDAP authentication, JDBC authentication, or add your custom authentication provide
-	In our application we have used customUserDetailsService and a passwordEncoder to build the AuthenticationManager


##	HttpSecurity configurations

-	HttpSecurity instance is used to define the rules and api mappings with roles
-	It also used to configure security functionalities like csrf, sessionManagement, custom login and logout etc



##	Custom Spring Security UserDetails

-	Create a POJO class that extends UserDetails
-	This class will be used by spring security

-----------------------------------------------
##	Login and Signup APIs

-	Create LoginRequest and SignUpRequest POJO's for handling signin and signup request
-	Create JwtAuthenticationResponse for JWT token in response
-	Create APIRespose for sending signup request response
-	Define Application specific expections
-	Create Authentication Controller to handle the signin and login requests 
---------------------------------------------------------
##	Using the Login and Signup APIs


![](https://www.callicoder.com/assets/images/post/large/Spring-Security-JWT-User-Registration.jpg)
![](https://www.callicoder.com/assets/images/post/large/spring-security-jwt-user-login.jpg)

##	Calling Protected APIs

-	Once we've obtained the access token using the login API, we can call any protected API by passing the accessToken in the Authorization header of the request like so -
			
				Authorization: Bearer <accessToken>


-------------------------------------------------
# Implementations

## SecurityConfig Class implementation

		
		@Configuration
		@EnableWebSecurity
		@EnableGlobalMethodSecurity(
				securedEnabled = true,
				jsr250Enabled = true,
				prePostEnabled = true
		)
		public class SecurityConfig extends WebSecurityConfigurerAdapter {
			
			@Bean
			public PasswordEncoder passwordEncoder() {
				return new BCryptPasswordEncoder();
			}
			
			@Autowired
			CustomUserDetailsService customUserDetailsService;

			@Autowired
			private JwtAuthenticationEntryPoint unauthorizedHandler;

			@Bean
			public JwtAuthenticationFilter jwtAuthenticationFilter() {
				return new JwtAuthenticationFilter();
			}
			
			@Bean
			@Override
			public AuthenticationManager authenticationManagerBean() throws Exception {
				return super.authenticationManagerBean();
			}
			
			@Override
			public void configure(AuthenticationManagerBuilder authenticationManagerBuilder) throws Exception {
				authenticationManagerBuilder
						.userDetailsService(customUserDetailsService)
						.passwordEncoder(passwordEncoder());
			}
			
			@Override
			protected void configure(HttpSecurity http) throws Exception {
				http
						.cors()
							.and()
						.csrf()
							.disable()
						.exceptionHandling()
							.authenticationEntryPoint(unauthorizedHandler)
							.and()
						.sessionManagement()
							.sessionCreationPolicy(SessionCreationPolicy.STATELESS)
							.and()
						.authorizeRequests()
							.antMatchers("/",
								"/favicon.ico",
								"/**/*.png",
								"/**/*.gif",
								"/**/*.svg",
								"/**/*.jpg",
								"/**/*.html",
								"/**/*.css",
								"/**/*.js")
								.permitAll()
							.antMatchers("/api/auth/**")
								.permitAll()
							.antMatchers("/api/user/checkUsernameAvailability", "/api/user/checkEmailAvailability")
								.permitAll()
							.antMatchers(HttpMethod.GET, "/api/polls/**", "/api/users/**")
								.permitAll()
							.anyRequest()
								.authenticated();

				// Add our custom JWT security filter
				http.addFilterBefore(jwtAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class);

			}

		}


##	JwtAuthenticationEntryPoint implementation
	
-	Just send the Unauthorized access for request without valid token and authorization headers
	
			@Component
			public class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint {

				private static final Logger logger = LoggerFactory.getLogger(JwtAuthenticationEntryPoint.class);
				@Override
				public void commence(HttpServletRequest httpServletRequest,
									 HttpServletResponse httpServletResponse,
									 AuthenticationException e) throws IOException, ServletException {
					logger.error("Responding with unauthorized error. Message - {}", e.getMessage());
					httpServletResponse.sendError(HttpServletResponse.SC_UNAUTHORIZED, e.getMessage());
				}
			}


##	Utility class for generating and verifying JWT

-	This class will be used for generation token and validating the token

				@Component
				public class JwtTokenProvider {

					private static final Logger logger = LoggerFactory.getLogger(JwtTokenProvider.class);

					@Value("${app.jwtSecret}")
					private String jwtSecret;

					@Value("${app.jwtExpirationInMs}")
					private int jwtExpirationInMs;

					public String generateToken(Authentication authentication) {

						UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();

						Date now = new Date();
						Date expiryDate = new Date(now.getTime() + jwtExpirationInMs);

						return Jwts.builder()
								.setSubject(Long.toString(userPrincipal.getId()))
								.setIssuedAt(new Date())
								.setExpiration(expiryDate)
								.signWith(SignatureAlgorithm.HS512, jwtSecret)
								.compact();
					}

					public Long getUserIdFromJWT(String token) {
						Claims claims = Jwts.parser()
								.setSigningKey(jwtSecret)
								.parseClaimsJws(token)
								.getBody();

						return Long.parseLong(claims.getSubject());
					}

					public boolean validateToken(String authToken) {
						try {
							Jwts.parser().setSigningKey(jwtSecret).parseClaimsJws(authToken);
							return true;
						} catch (SignatureException ex) {
							logger.error("Invalid JWT signature");
						} catch (MalformedJwtException ex) {
							logger.error("Invalid JWT token");
						} catch (ExpiredJwtException ex) {
							logger.error("Expired JWT token");
						} catch (UnsupportedJwtException ex) {
							logger.error("Unsupported JWT token");
						} catch (IllegalArgumentException ex) {
							logger.error("JWT claims string is empty.");
						}
						return false;
					}
				}

-	JWT Properties in application.properties

				## App Properties
				app.jwtSecret= JWTSuperSecretKey
				app.jwtExpirationInMs = 604800000




##	Custom Spring Security AuthenticationFilter

				
					public class JwtAuthenticationFilter extends OncePerRequestFilter {

							@Autowired
							private JwtTokenProvider tokenProvider;

							@Autowired
							private CustomUserDetailsService customUserDetailsService;

							private static final Logger logger = LoggerFactory.getLogger(JwtAuthenticationFilter.class);

							@Override
							protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
								try {
									String jwt = getJwtFromRequest(request);

									if (StringUtils.hasText(jwt) && tokenProvider.validateToken(jwt)) {
										Long userId = tokenProvider.getUserIdFromJWT(jwt);

										UserDetails userDetails = customUserDetailsService.loadUserById(userId);
										UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
										authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));

										SecurityContextHolder.getContext().setAuthentication(authentication);
									}
								} catch (Exception ex) {
									logger.error("Could not set user authentication in security context", ex);
								}

								filterChain.doFilter(request, response);
							}

							private String getJwtFromRequest(HttpServletRequest request) {
								String bearerToken = request.getHeader("Authorization");
								if (StringUtils.hasText(bearerToken) && bearerToken.startsWith("Bearer ")) {
									return bearerToken.substring(7, bearerToken.length());
								}
								return null;
							}
						}
						
						
-	Another Implementations
			
					public class JwtTokenFilter extends GenericFilterBean {

							private JwtTokenProvider jwtTokenProvider;

							public JwtTokenFilter(JwtTokenProvider jwtTokenProvider) {
								this.jwtTokenProvider = jwtTokenProvider;
							}

							@Override
							public void doFilter(ServletRequest req, ServletResponse res, FilterChain filterChain)
								throws IOException, ServletException {

								String token = jwtTokenProvider.resolveToken((HttpServletRequest) req);
								if (token != null && jwtTokenProvider.validateToken(token)) {
									Authentication auth = token != null ? jwtTokenProvider.getAuthentication(token) : null;
									SecurityContextHolder.getContext().setAuthentication(auth);
								}
								filterChain.doFilter(req, res);
							}

						}

----------------------------------------------------------

##	Authentication Controller


				
					@RestController
					@RequestMapping("/api/auth")
					public class AuthController {

						@Autowired
						AuthenticationManager authenticationManager;

						@Autowired
						UserRepository userRepository;

						@Autowired
						RoleRepository roleRepository;

						@Autowired
						PasswordEncoder passwordEncoder;

						@Autowired
						JwtTokenProvider tokenProvider;

						@PostMapping("/signin")
						public ResponseEntity<?> authenticateUser(@Valid @RequestBody LoginRequest loginRequest) {

							Authentication authentication = authenticationManager.authenticate(
									new UsernamePasswordAuthenticationToken(
											loginRequest.getUsernameOrEmail(),
											loginRequest.getPassword()
									)
							);

							SecurityContextHolder.getContext().setAuthentication(authentication);

							String jwt = tokenProvider.generateToken(authentication);
							return ResponseEntity.ok(new JwtAuthenticationResponse(jwt));
						}

						@PostMapping("/signup")
						public ResponseEntity<?> registerUser(@Valid @RequestBody SignUpRequest signUpRequest) {
							if(userRepository.existsByUsername(signUpRequest.getUsername())) {
								return new ResponseEntity(new ApiResponse(false, "Username is already taken!"),
										HttpStatus.BAD_REQUEST);
							}

							if(userRepository.existsByEmail(signUpRequest.getEmail())) {
								return new ResponseEntity(new ApiResponse(false, "Email Address already in use!"),
										HttpStatus.BAD_REQUEST);
							}

							// Creating user's account
							User user = new User(signUpRequest.getName(), signUpRequest.getUsername(),
									signUpRequest.getEmail(), signUpRequest.getPassword());

							user.setPassword(passwordEncoder.encode(user.getPassword()));

							Role userRole = roleRepository.findByName(RoleName.ROLE_USER)
									.orElseThrow(() -> new AppException("User Role not set."));

							user.setRoles(Collections.singleton(userRole));

							User result = userRepository.save(user);

							URI location = ServletUriComponentsBuilder
									.fromCurrentContextPath().path("/api/users/{username}")
									.buildAndExpand(result.getUsername()).toUri();

							return ResponseEntity.created(location).body(new ApiResponse(true, "User registered successfully"));
						}
					}















